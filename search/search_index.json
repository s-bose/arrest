{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"Arrest  <p>Enable data validation for REST APIs.</p> <p>Arrest is an HTTP client library with an easy and declarative way of defining, managing, and calling RESTful HTTP APIs with type validation, retries, exception handling, and other batteries included.</p> <p>Arrest lets you define your RESTful API services in a simple encapsulation that takes care of the following: 1. Type validation for request and response data 2. HTTP request retries 3. Manage your services definitions in one place 4. Exception handling 5. Hooks for custom exceptions 6. Callbacks 7. Automatic code generation from OpenAPI Schema</p> <p>Here is an example of a typical client-side functions for interacting with an HTTP Service. </p> <p>And here is the same functionality achieved using Arrest. </p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#using-pip","title":"using <code>pip</code>","text":"<pre><code>$ pip install arrest\n</code></pre>"},{"location":"#using-poetry","title":"using <code>poetry</code>","text":"<pre><code>$ poetry add arrest\n</code></pre>"},{"location":"#using-github","title":"using <code>github</code>","text":"<pre><code>$ pip install git+https://github.com/s-bose/arrest.git@master\n</code></pre>"},{"location":"#philosophy-of-arrest","title":"Philosophy of Arrest","text":"<p>Arrest was made as a result of the repeated boilerplate that comes with managing different internal / external services.</p> <p>Imagine you have to call an HTTP server <code>http://example.com/api/v1</code> from your python code. For just a single GET api call we have a rather simple solution, make a method around the HTTP call.</p> <pre><code>import httpx\n\nasync def get_posts(url: str = \"http://example.com/api/v1\"):\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url)\n            response.raise_for_status()\n            return response.json()\n        except httpx.HTTPStatusError as exc:\n            logging.warning(f\"something went wrong, {exc.response.status_code}\")\n            return exc.response.json()\n</code></pre> <p>The problem arises when you have more than one method, and more than one endpoint to consider. We could create a sophisticated class containing the list of available endpoints and the methods. But it is a lot of boilerplate in trying to do something as simple as communicating with an HTTP server, even more so when we have multiple servers to interact with, e.g, in a microservice architecture.</p> <p>Arrest attempts to simplify this by letting you create a single configuration using <code>services</code> and <code>resources</code> and <code>handlers</code> which creates a complete unit that can be used anywhere.</p> <p>Just define your service, i.e, the main server url, and a set of resources, e.g, <code>/users</code>, <code>/articles</code>. We assume the RESTful apis provided by the service are resource-oriented.</p> <pre><code>from arrest import Service, Resource\n\nuser_resource = Resource(\n    name=\"users\",\n    route=\"/users\",\n    handlers=[\n        (\"GET\", \"/\"),\n        (\"GET\", \"/{user_id:str}\"),\n        (\"POST\", \"/\", NewUserRequest),\n        (\"PATCH\", \"/{user_id:str}\", UpdateUserRequest)\n    ]\n)\n\nexample_svc = Service(\n    name=\"example\",\n    url=\"http://example.com/api/v1\",\n    resources=[user_resource]\n)\n</code></pre> <p>Now that our service is configured we can simply use <code>example_svc</code> anywhere we want to use its functionalities.</p> <pre><code>await example_svc.users.get(\"/\")\nawait example_svc.users.get(\"/59e66b94-9d94-4380-8101-c0ebf60bbff4\")\nawait example_svc.users.post(\"/\", request=NewUserRequest(email=\"abc@email.com\", password=\"hopefullyhashed\"))\nawait example_svc.users.patch(\"/\", request=UpdateUserRequest(password=\"hopefullyhashedagain\"))\n</code></pre> <p>You might also have noticed that a custom request DTOs can be provided such as <code>NewUserRequest</code> and <code>UpdateUserRequest</code>. With this you can enable data validation and structure to your request data. Although as of now these have to be pydantic classes.</p>"},{"location":"#caveats-and-future","title":"Caveats and Future","text":"<p>Arrest is still in its infancy. There are a lot of new features we would love to integrate in future. But there are certain caveats and assumptions that Arrest makes which are important to know.</p> <ol> <li>It currently only supports JSON as both request and response. So if your service does not deal with JSON then probably you have to do it the old way.</li> <li>It follows the resource-oriented REST api design. If your service does not have clear distinction for different resources and CRUD methods to access them then it might be a bit wonky to integrate it properly within Arrest.</li> </ol> <p>All things considered, it is still a work in progress, and we would greatly appreciate if you find any bugs and notify us in the issue-tracker.</p>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#service","title":"<code>Service</code>","text":"<p>A python class to define a service. Contains a base url for the main HTTP service. Resources can be added to a service.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the service</p> required <code>url</code> <code>str</code> <p>Base url of the service</p> required <code>resources</code> <code>Optional[list[Resource]]</code> <p>A list of resources provided by the service</p> <code>[]</code> <code>client</code> <code>Optional[AsyncClient]</code> <p>An httpx.AsyncClient instance</p> <code>None</code> <code>retry</code> <code>Optional[int]</code> <p>Optional argument to specify the number of retries across all resources</p> <code>None</code> <code>kwargs</code> <code>Unpack[HttpxClientInputs]</code> <p>Additional httpx.AsyncClient parameters. see more</p> <code>{}</code>"},{"location":"api/#arrest.service.Service.add_resource","title":"<code>add_resource(resource, client=None, retry=None, **kwargs)</code>","text":"<p>Add a new resource to the service</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>Resource</code> <p>The new resource instance</p> required"},{"location":"api/#arrest.service.Service.request","title":"<code>request(path, method, **kwargs)</code>  <code>async</code>","text":"<p>Helper function to make a request directly from the service level</p> Note <p>If you provide <code>path</code> as an empty string or <code>/</code>, this would try to find a root resource definition, if any</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Requested path needs to have the following syntax: <code>/{resource_route}/{handler_route}</code></p> required <code>method</code> <code>Methods</code> <p>Requested HTTP Method</p> required"},{"location":"api/#resource","title":"<code>Resource</code>","text":"<p>A python class used to define a RESTful resource.</p> Usage <pre><code>&gt;&gt;&gt; from arrest import Resource\n\n&gt;&gt;&gt; user_resource = Resource(name=\"user\", route=\"/users\", handlers=[(\"GET\", \"/\")])\n</code></pre> <p>Handlers can be provided as a list of tuple, dictionary or instances of <code>ResourceHandler</code></p> <p>If provided as a dict or <code>ResourceHandler</code>, the keys / fields have to be set according to the <code>ResourceHandler</code> definiion.</p> <p>If provided as a tuple, at minimum 2 entries <code>(method, route)</code> or a maximum of 5 entries (method, route, request, response, callback) can be defined.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Unique name of the resource</p> <code>None</code> <code>route</code> <code>Optional[str]</code> <p>Unique route to the resource</p> required <code>response_model</code> <code>Optional[T]</code> <p>Pydantic datamodel to wrap the json response</p> <code>None</code> <code>handlers</code> <code>Union[List[ResourceHandler], List[Mapping[str, Any]], List[Tuple[Any, ...]]]</code> <p>List of handlers</p> <code>None</code> <code>client</code> <code>Optional[AsyncClient]</code> <p>An httpx.AsyncClient instance</p> <code>None</code> <code>retry</code> <code>Optional[int]</code> <p>Optional argument to specify the number of retries</p> <code>None</code> <code>kwargs</code> <code>Unpack[HttpxClientInputs]</code> <p>Additional httpx.AsyncClient parameters, see more</p> <code>{}</code>"},{"location":"api/#arrest.resource.Resource.request","title":"<code>request(method, path, request=None, headers=None, query=None, **kwargs)</code>  <code>async</code>","text":"<p>Makes an HTTP request against a handler route</p> Usage <pre><code>&gt;&gt;&gt; user_resource.user.request(method=\"GET\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Methods</code> <p>The HTTP method for the request</p> required <code>path</code> <code>str</code> <p>Path to a handler specified in the resource</p> required <code>request</code> <code>Union[BaseModel, Mapping[str, Any], None]</code> <p>A pydantic object containing the necessary fields to make an http request to the handler url</p> <p>Must match the corresponding <code>handler.request</code> pydantic model</p> <code>None</code> <code>headers</code> <code>Optional[Mapping[str, str]]</code> <p>A multi-dict or <code>httpx.Headers</code> containing additional header key-value pairs</p> <code>None</code> <code>query</code> <code>Optional[Mapping[str, str]]</code> <p>A multi-dict or <code>httpx.QueryParams</code> containing additional query-param key-value pairs</p> <code>None</code> <code>**kwargs</code> <p>Keyword-arguments matching the path params, if any</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Any | None</code> <p>A JSON response in form of a list or dict <code>or</code>, Deserialized into the response pydantic model <code>or</code>, Return value of the callback fn</p>"},{"location":"api/#arrest.resource.Resource.get","title":"<code>get(path, request=None, headers=None, query=None, **kwargs)</code>  <code>async</code>","text":"<p>Makes a <code>HTTP GET</code> request</p> <p>see request</p>"},{"location":"api/#arrest.resource.Resource.post","title":"<code>post(path, request=None, headers=None, query=None, **kwargs)</code>  <code>async</code>","text":"<p>Makes a <code>HTTP POST</code> request</p> <p>see request</p>"},{"location":"api/#arrest.resource.Resource.put","title":"<code>put(path, request=None, headers=None, query=None, **kwargs)</code>  <code>async</code>","text":"<p>Makes a <code>HTTP PUT</code> request</p> <p>see request</p>"},{"location":"api/#arrest.resource.Resource.patch","title":"<code>patch(path, request=None, headers=None, query=None, **kwargs)</code>  <code>async</code>","text":"<p>Makes a <code>HTTP PATCH</code> request</p> <p>see request</p>"},{"location":"api/#arrest.resource.Resource.delete","title":"<code>delete(path, request=None, headers=None, query=None, **kwargs)</code>  <code>async</code>","text":"<p>Makes a <code>HTTP DELETE</code> request</p> <p>see request</p>"},{"location":"api/#arrest.resource.Resource.head","title":"<code>head(path, request=None, headers=None, query=None, **kwargs)</code>  <code>async</code>","text":"<p>Makes a <code>HTTP HEAD</code> request</p> <p>see request</p>"},{"location":"api/#arrest.resource.Resource.options","title":"<code>options(path, request=None, headers=None, query=None, **kwargs)</code>  <code>async</code>","text":"<p>Makes a <code>HTTP OPTIONS</code> request</p> <p>see request</p>"},{"location":"api/#arrest.resource.Resource.handler","title":"<code>handler(path)</code>","text":"<p>Decorator to bind a custom handler to the resource</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path relative to the current resource</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Any</p>"},{"location":"api/#httpx-client-arguments","title":"Httpx Client Arguments","text":"<p>               Bases: <code>TypedDict</code></p> <p>a typed dict to check for all the necessary fields for building an <code>httpx.AsyncClient</code> instance</p> <p>Parameters:</p> <ul> <li>auth - (optional) An authentication class to use when sending requests.</li> <li>params - (optional) Query parameters to include in request URLs, as a string, dictionary, or sequence of two-tuples.</li> <li>headers - (optional) Dictionary of HTTP headers to include when sending requests.</li> <li>cookies - (optional) Dictionary of Cookie items to include when sending requests.</li> <li>verify - (optional) SSL certificates (a.k.a CA bundle) used to verify the identity of requested hosts. Either <code>True</code> (default CA bundle), a path to an SSL certificate file, an <code>ssl.SSLContext</code>, or <code>False</code> (which will disable verification).</li> <li>cert - (optional) An SSL certificate used by the requested host to authenticate the client. Either a path to an SSL certificate file, or two-tuple of (certificate file, key file), or a three-tuple of (certificate file, key file, password).</li> <li>http2 - (optional) A boolean indicating if HTTP/2 support should be enabled. Defaults to <code>False</code>.</li> <li>proxies - (optional) A dictionary mapping HTTP protocols to proxy URLs (deprecated).</li> <li>mounts - (optional) A dictionary mapping HTTP protocols to proxy URLs</li> <li>timeout - (optional) The timeout configuration to use when sending requests.</li> <li>follow_redirects - (optional) A boolean indicating whether to follow redirects. See more</li> <li>limits - (optional) The limits configuration to use.</li> <li>max_redirects - (optional) The maximum number of redirect responses that should be followed.</li> <li>event_hooks - (optional) - A dictionary to set event hook callbacks for request and response events. See more</li> <li>transport - (optional) A transport class to use for sending requests over the network.</li> <li>trust_env - (optional) Enables or disables usage of environment variables for configuration.</li> <li>default_encoding - (optional) The default encoding to use for decoding response text, if no charset information is included in a response Content-Type header. Set to a callable for automatic character set detection. Default: \"utf-8\".</li> </ul> <p>Parameters not included</p> <ul> <li>base_url - Already used internally in <code>Resource</code>, therefore no need to set it from kwargs</li> <li>app - Not required currently as Arrest is primarily built to make external http requests</li> </ul>"},{"location":"api/#resourcehandler","title":"<code>ResourceHandler</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A pydantic class defining a resource handler</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Methods</code> <p>HTTP Method for the handler</p> required <code>route</code> <code>str</code> <p>Unique path to the handler from its parent resource</p> required <code>request</code> <code>T</code> <p>Python type to validate the request with</p> required <code>response</code> <code>T</code> <p>Python type to deserialize the HTTP response</p> required <code>callback</code> <code>Callable</code> <p>A callable (sync or async) to execute with the HTTP response</p> required"},{"location":"api/#exceptions","title":"Exceptions","text":""},{"location":"api/#arresterror","title":"ArrestError","text":"<p>               Bases: <code>BaseException</code></p> <p>used in error situations</p> Source code in <code>arrest/exceptions.py</code> <pre><code>def __init__(self, *args: object) -&gt; None:\n    super().__init__(*args)\n</code></pre> <p>base class for all Exception. Used in situations that are not one of the following</p>"},{"location":"api/#arresthttpexception","title":"ArrestHTTPException","text":"<p>               Bases: <code>ArrestError</code></p> Source code in <code>arrest/exceptions.py</code> <pre><code>def __init__(self, status_code: int, data: dict | str) -&gt; None:\n    self.status_code = status_code\n    self.data = data\n</code></pre> <p>used for exceptions during HTTP calls</p> <ul> <li><code>.status_code</code> - str status code of the exception, 500 for internal server error</li> <li><code>.data</code> - str json response for the exception</li> </ul>"},{"location":"api/#notfoundexception","title":"NotFoundException","text":"<p>               Bases: <code>ArrestError</code></p> Source code in <code>arrest/exceptions.py</code> <pre><code>def __init__(self, message: str):\n    self.message = message\n</code></pre> <p>base class for all NotFound-type exceptions</p>"},{"location":"api/#handlernotfound","title":"HandlerNotFound","text":"<p>               Bases: <code>NotFoundException</code></p> Source code in <code>arrest/exceptions.py</code> <pre><code>def __init__(self, message: str):\n    super().__init__(message)\n</code></pre> <p>raised when no matching handler is found for the requested path</p> <ul> <li><code>.message</code> - str</li> </ul>"},{"location":"api/#resourcenotfound","title":"ResourceNotFound","text":"<p>               Bases: <code>NotFoundException</code></p> Source code in <code>arrest/exceptions.py</code> <pre><code>def __init__(self, message: str):\n    super().__init__(message)\n</code></pre> <p>raised when no matching resource is found for the service</p> <ul> <li><code>.message</code> - str</li> </ul>"},{"location":"api/#conversionerror","title":"ConversionError","text":"<p>               Bases: <code>ArrestError</code></p> Source code in <code>arrest/exceptions.py</code> <pre><code>def __init__(self, *args: object) -&gt; None:\n    super().__init__(*args)\n</code></pre> <p>raised when Arrest cannot convert path-parameter type using any of the existing converters</p>"},{"location":"api/#openapigenerator","title":"OpenAPIGenerator","text":"<p>class for generating Arrest services, resources and schema components from OpenAPI specification (&gt;= v3.0) Generates three files:</p> <ol> <li>models.py (contains OpenAPI Schema component definitions)</li> <li>resources.py (Arrest Resources based on the path items)</li> <li>services.py (Arrest Services using the resources)</li> </ol> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>an HTTP url or full path to the OpenAPI specification (json or yaml)</p> required <code>output_path</code> <code>str</code> <p>path where the generated files will be saved</p> required <code>dir_name</code> <code>Optional[str]</code> <p>(optional) specify the folder name containing the files</p> <code>None</code> <code>use_pydantic_v2</code> <code>Optional[bool]</code> <p>(optional) use pydantic v2 (default: False)</p> <code>False</code> Source code in <code>arrest/openapi/parser.py</code> <pre><code>def __init__(\n    self,\n    *,\n    url: str,\n    output_path: str,\n    dir_name: Optional[str] = None,\n    use_pydantic_v2: Optional[bool] = False,\n) -&gt; None:\n    \"\"\"\n    class for generating Arrest services, resources and schema\n    components from OpenAPI specification (&gt;= v3.0)\n    Generates three files:\n\n    1. models.py (contains OpenAPI Schema component definitions)\n    2. resources.py (Arrest Resources based on the path items)\n    3. services.py (Arrest Services using the resources)\n\n\n    Parameters:\n        url:\n            an HTTP url or full path to the OpenAPI specification (json or yaml)\n        output_path:\n            path where the generated files will be saved\n        dir_name:\n            (optional) specify the folder name containing the files\n        use_pydantic_v2:\n            (optional) use pydantic v2 (default: False)\n\n    \"\"\"\n    self.url: str = url\n    self.output_path: str = output_path\n    self.dir_name: str = dir_name\n    self.use_pydantic_v2 = use_pydantic_v2\n</code></pre>"},{"location":"api/#arrest.openapi.OpenAPIGenerator.generate_schema","title":"<code>generate_schema(fmt=None)</code>","text":"<p>Generates the boilerplate files against an OpenAPI Spec</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>Optional[Format]</code> <p>specification format [json, yaml, yml]</p> <code>None</code> <p>Raises:</p> Type Description <code>ArrestError</code> <p>if the output path does not exist</p> Source code in <code>arrest/openapi/parser.py</code> <pre><code>def generate_schema(self, fmt: Optional[Format] = None):\n    \"\"\"Generates the boilerplate files against an OpenAPI Spec\n\n    Parameters:\n        fmt (Optional[Format], optional): specification format [json, yaml, yml]\n\n    Raises:\n        ArrestError: if the output path does not exist\n    \"\"\"\n    openapi_bytes = self.download_openapi_spec()\n    fmt = fmt if fmt else self.url.split(\".\")[-1]\n    openapi: OpenAPI = self.parse_openapi(fmt=fmt, data=io.BytesIO(openapi_bytes))\n\n    output_path = Path(self.output_path)\n    if not output_path.exists():\n        raise ArrestError(\"output path does not exist\")\n\n    service_name = self.dir_name or self.get_service_name(openapi)\n    output_path = output_path / service_name\n    schema_path = output_path / OPENAPI_SCHEMA_FILENAME\n\n    Path.mkdir(output_path, exist_ok=True)\n\n    self.generate_component_schema(input_bytes=openapi_bytes, schema_path=schema_path)\n    resources = self.generate_resource_file(\n        openapi=openapi, schema_path=schema_path, resource_path=output_path\n    )\n    self.generate_service_file(openapi=openapi, service_path=output_path, resources=resources)\n    InitTemplate(destination_path=output_path).render_and_save()\n</code></pre>"},{"location":"configuring-request/","title":"Configuring your request","text":"<p>If you want to enrich your HTTP request with additional arguments such as headers or query parameters, you can specify them in the HTTP request as dictionaries in <code>headers</code> and <code>query</code> fields.</p> <p>Additionally, Arrest offers custom field types <code>Header</code>, <code>Query</code> and <code>Body</code>, which are inherited from pydantic's <code>FieldInfo</code>, that you can use in defining your pydantic request model.</p>"},{"location":"configuring-request/#header","title":"Header","text":"<p>You can use the <code>headers</code> keyword-argument in the request method to directly pass a set of key-value pairs as headers.</p> <p>using <code>headers</code> kwarg</p> <pre><code>await service.user.get(\"/posts\", headers={\"x-max-age\": \"20\", \"x-organization\": \"abc-123\"})\n</code></pre> <p>If you want resource-wide shared header definition, you can set it in the <code>Resource</code> definition as well. You can use both of these together as all the headers will be collected and sent as a whole.</p> <p>using <code>Resource.headers</code></p> <pre><code>service.add_resource(\n    Resource(\n        route=\"/user\",\n        handlers=[\n            (Methods.GET, \"/profile\"),\n        ],\n        headers={\"x-organization\": \"abc-123\"}\n    )\n)\n\nawait service.user.get(\"/posts\", headers={\"x-max-age\": \"20\"})\n</code></pre> <p>If you want to define your headers as part of your request model, use <code>arrest.params.Header</code> to specify the header fields in your request. This is useful when you want to group together all the components of your request inside one data model.</p> <p>using <code>Header</code> class</p> <pre><code>from arrest.params import Header\n\nclass HeaderRequest(BaseModel):\n    x_max_age: str = Header(...)\n    x_cookie: str = Header(...)\n\nawait service.user.get(\"/posts\", request=HeaderRequest(x_max_age=\"20\", \"x_cookie\": \"xyz\"))\n</code></pre> <p>Warning</p> <p>Arrest does NOT convert any non-str values to str and convert <code>snake_case</code> to <code>kebab-case</code> before sending the fields as headers in the request. If you want to send <code>kebab-case</code> headers you need to:</p> <ol> <li> <p>specify them as <code>kebab-case</code> in the dictionary passed to the <code>headers</code> keyword or Resource class definition.</p> </li> <li> <p>Use <code>alias</code> in your pydantic field (if you are using pydantic@v2 then you need to use <code>serialization_alias</code> instead).</p> </li> <li> <p>Set the pydantic config to <code>allow_population_by_field_name</code> (if pydantic@v2, use <code>ConfigDict.populate_by_name</code>).</p> </li> </ol> <pre><code>class UserRequest(BaseModel):\n    x_user_agent: str = Header(serialization_alias=\"x-user-agent\")\n\n    model_config = ConfigDict(populate_by_name=True)\n\nawait service.user.post(\"/\", request=UserRequest(x_user_agent=\"mozila\"))\n# header = {\"x-user-agent\": \"mozila\"}\n</code></pre> <pre><code># using pydantic@v1\n\nclass UserRequest(BaseModel):\n    x_user_agent: str = Header(alias=\"x-user-agent\")\n\n    class Config:\n        allow_population_by_field_name = True\n\nawait service.user.post(\"/\", request=UserRequest(x_user_agent=\"mozila\"))\n# header = {\"x-user-agent\": \"mozila\"}\n</code></pre>"},{"location":"configuring-request/#query","title":"Query","text":"<p>Similar to headers, you can provide your request-specific query parameters as a dict to the <code>query</code> kwarg in the request method.</p> <p>using <code>query</code> kwarg</p> <pre><code>await service.user.get(\"/posts\", query={\"limit\": 100, \"username\": \"abc\"})\n</code></pre> <p>If you want to define your query parameters as part of your request model, use <code>arrest.params.Query</code> to specify the query fields in your request. Whatever field is marked as <code>Query</code> will be attached as a query parameter in the request.</p> <p>using <code>Query</code> class</p> <pre><code>from arrest.params import Query\n\nclass QueryRequest(BaseModel):\n    limit: int = Query(...)\n    name: str = Query(...)\n    index: int | None = Query()\n\nawait service.user.get(\"/posts\", request=QueryRequest(limit=100, name=\"abc\", index=10))\n</code></pre>"},{"location":"configuring-request/#body","title":"Body","text":"<p>Request body is supplied with the keyword argument <code>request</code> in your call. This can be a pydantic instance, a simple dictionary, a list or any object that can be jsonified.</p> <p>However, if the handler for the path has a request type specified, the request body must match the type (or be convertible to it). You can make use of <code>arrest.params.Body</code> when defining the body fields, although fields that don't have any defaults will be automatically parsed as body.</p> <p>using request type</p> <pre><code>from arrest.params import Body\n\nclass BodyRequest(BaseModel):\n    name: str = Body(...)\n    email: str\n    password: str\n    role: Optional[str]\n    is_active: bool\n\n# both of the following should work\nawait service.user.post(\"/\", request=BodyRequest(name=\"abc\", email=\"abc@email.com\", password=\"123\", role=\"ADMIN\", is_active=False))\nawait service.user.post(\"/\", request={\"name\": \"abc\", \"email\": \"abc@email.com\", \"password\": \"123\", \"role\": \"ADMIN\", \"is_active\": False})\n</code></pre> <p>If you do not have a request type specified to the handler, you can still pass a pydantic object but no model validation will take place and Arrest will extract the fields as per their defaults. You can also pass a plain dictionary or a list as request. They will get passed as json payload.</p> <p>regarding json payloads</p> <p>Arrest uses <code>orjson</code> for serializing the request payload. This was chosen because the stdlib <code>json</code> does not parse datetime which <code>orjson</code> does.</p>"},{"location":"configuring-request/#additional-configuration","title":"Additional Configuration","text":"<p>Arrest also allows providing other http parameters such as cookies, auth, transport, etc, or even your own instance of <code>httpx.AsyncClient</code> (or other classes subclassing it), if you choose to do so. If you want to customize the httpx client and specify more parameters either at resource-level or at service-level, you can check out Resources &amp; Services.</p>"},{"location":"configuring-request/#path-parameters","title":"Path parameters","text":"<p>Path parameters are a bit tricky as they are not set as pydantic fields. To define a handler that takes a path parameter, you have to specify the path-params inside curlys with (optional) their types.</p> <pre><code>Resource(\n    route=\"/abc\",\n    handlers=[\n        (\"GET\", \"/user/{user_id}\"),\n        (\"GET\", \"/user/{user_id:uuid}\"),\n        (\"GET\", \"/user/{user_id}/comments/{comment_id:int}\")\n    ]\n)\n</code></pre> <p>Regarding multiple handlers</p> <p>If you specify handlers with the same path parameter but different type hints, the most recent one will override all the others. So in the above example, we only have one handler <code>GET /user/{user_id:uuid}</code></p> <p>This is because we keep track of unique handlers with the pair <code>&lt;method, route&gt;</code> where <code>route</code> is the handler route with its type hint removed. Subsequent handler definitions with varying path parameter types will thus override the entry.</p> <p>There are many ways you can supply the path param. The most common way is to use a python f-string (considering the path-param is dynamic)</p> <pre><code>...\nuser_id = uuid.UUID(\"ca80a889-8811-4e65-86bb-5e7c0c6e07cf\")\n\n...\nservice.abc.get(f\"/user/{user_id}\")\n</code></pre> <p>Alternatively, you can pass it as a static string. <pre><code>service.abc.get(\"/user/ca80a889-8811-4e65-86bb-5e7c0c6e07cf\")\n</code></pre></p> <p>if f-strings are not cool enough for you, there is another alternative, albeit experimental, where you can pass the path-parameter(s) as kwargs in your request function.</p> <pre><code>service.abc.get(\"/user\", user_id=user_id)\n# or\nservice.abc.get(f\"/user/{user_id}/comments\", comment_id=comment_id)\n</code></pre> <p>Note</p> <p>If the resource contains only one handler and that handler url contains multiple path params like this:</p> <pre><code>Resource(\n    route=\"/user\",\n    handlers=[\n        (Methods.POST, \"/profile/{id:int}/comments/{comment_id:int}\"),\n    ],\n)\n</code></pre> <p>then you can pass all the path_params as kwargs in the request by specifying the url as <code>/user</code></p> <pre><code>user.post(\"/profile\", id=123, comment_id=456)\nuser.post(\"/profile/123\", comment_id=456)\nuser.post(\"/profile/123/comments\", comment_id=456)\nuser.post(\"/profile/123/comments/456\") # all 4 would work\n</code></pre> <p>However if it contains specific paths from <code>/profile</code>, then you need to specify the sub-resource name of the specific <code>profile</code></p> <pre><code>Resource(\n    route=\"/user\",\n    handlers=[\n        (Methods.POST, \"/profile/{id:int}\"),\n        (Methods.POST, \"/profile/{id:int}/comments/{comment_id:int}\"),\n    ],\n)\n\nuser.post(\"/profile\", id=123, comments=456) # wont work\nuser.post(\"/profile/123/comments/\", comments=456) # will work\n</code></pre> <p>About url paths</p> <p>If the endpoint you are trying to call ends with a trailing slash (/), you need to specify the relative path to the handler also with the trailing slash (/).</p> <p><pre><code>(GET,  \"\"),\n(GET, \"/\")\n</code></pre> are considered two different handlers. This does not apply when you are passing kwargs as path-parameters and Arrest will construct and find a match for the full path.</p> <pre><code># both will work\nuser.post(\"/profile/123/comments\", comments=456)\nuser.post(\"/profile/123/comments/\", comments=456)\n</code></pre>"},{"location":"configuring-request/#using-converters","title":"Using converters","text":"<p>Arrest uses converters for the following types to validate and stringify the passed kwarg path-params to construct the url. - <code>int</code> - <code>float</code> - <code>str</code> - <code>UUID</code></p> <p>If you want to run with a custom datatype as path-param, you can add a converter and regex for it by subclassing <code>arrest.converters.Converter</code> and add the converter to Arrest by <code>add_converter(...)</code></p>"},{"location":"dev-note/","title":"Developer's Note","text":""},{"location":"dev-note/#regarding-path-parameter-idiosyncrasies","title":"Regarding Path Parameter idiosyncrasies","text":"<p>If you decide to specify your path parameters using kwargs, only two options are there. - Using kwargs as path parameters - Embedding path parameters as f-strings</p> <p>The second option is less error-prone as the full URL path is being constructed, while the first option is preferable if you don't like working with f-strings. It is an experimental feature which I thought would be beneficial but only time will tell how useful it really is.</p>"},{"location":"dev-note/#pydantic-v1-issues","title":"Pydantic V1 Issues","text":"<p>If you are using pydantic v1, it is highly recommended to switch to v2 which offers stricter type-safety, validation and faster parsing. However, if you are still using it, here are a few caveats I observed that you might want to take into consideration:</p> <ol> <li> <p>In v1, <code>int</code> and <code>float</code> are implicitly coerced to <code>str</code>, whereas in v2 this raises a <code>ValidationError</code>, because v2 by default disables type coercion     from <code>int</code> and <code>float</code> to <code>str</code>. This might be a problem when you are using pydantic request models in v1. For example, consider the following:</p> <pre><code>from pydantic import BaseModel\nfrom arrest.params import Query\n\nclass UserRequest(BaseModel):\n    id: str\n\nawait service.user.post(\"/profile\", request=UserRequest(id=15)) # request body = {\"id\": \"15\"}\n</code></pre> </li> </ol> <p>The above will throw a <code>ValidationError</code> in pydantic v2 unless you have <code>coerce_numbers_to_str=True</code> in <code>ConfigDict</code></p> <ol> <li> <p>In pydantic v1, <code>parse_obj_as</code> helper function is used to convert objects of one type to another arbitrarty python type, as opposed to using <code>TypeAdapter</code> from Pydantic v2. The <code>parse_obj_as</code> function is inconsistent with the type conversions in comparison to <code>TypeAdapter</code>, because it does not throw a <code>ValidationError</code> if an object of class B is attempted to be parsed as class A. For example, consider this:</p> <pre><code>from pydantic import BaseModel\nfrom arrest import Resource\nfrom .service import service\n\nclass UserRequest(BaseModel):\n    id: Optional[int] = None\n    name: Optional[str] = None\n\nclass FooBar(BaseModel):\n    foo: str\n    bar: str\n\nservice.add_resource(\n    Resource(\n        name=\"user\",\n        path=\"/user\",\n        handlers=[\n            (\"POST\", \"/profile\", UserRequest),\n        ]\n    )\n)\nawait service.user.post(\"/profile\", request=FooBar(foo=\"foo\", bar=\"bar\"))\n</code></pre> </li> </ol> <p>The above will fail in v2 with ValidationError during attempting to parse the supplied request instance of <code>FooBar</code> as <code>UserRequest</code>. But it will succeed and a request will be sent but the body will be an empty <code>UserRequest</code> instance, i.e. <code>{\"id\": None, \"name\": None}</code>.</p> <p>Note: this can still raise ValidationError in v1, if, let's say, the <code>UserRequest</code> fields are all required, and non-overlapping with the fields in <code>FooBar</code>.</p>"},{"location":"examples/","title":"Examples","text":"<p>You can refer to the <code>example</code> folder for different use cases.</p> <p>The <code>example_service</code> contains a minimal FastAPI application for task management with CRUD endpoints for <code>users</code> and <code>tasks</code>.</p> <p>It uses in-memory dictionaries for data storage, so of course this is just for testing and learning purposes.</p> <p>It comes with a set of test files which test compatibility with 3 different types.</p> <ol> <li>Pydantic BaseModel</li> <li>Python dataclasses</li> <li>No class, rely on dicts and lists</li> </ol>"},{"location":"examples/#packages-used","title":"Packages Used","text":"<ol> <li>FastAPI==0.112.2</li> <li>Pydantic==2.8.2</li> <li>Uvicorn==0.30.6</li> </ol>"},{"location":"examples/#installation","title":"Installation","text":"<p>To run the example FastAPI application, simply go to the example directory at the project root, and run <code>bash run.sh</code>, and you shoule be able to access the Swagger docs at http://localhost:8080/docs</p> <p>Alternatively, you can set up your own virtualenv, and install the <code>requirements.example.txt</code> and run <code>uvicorn app.main:app</code>.</p> <p>To generate the Arrest boilerplate from the OpenAPI specs, simply run the FastAPI application using <code>uvicorn</code> at http://127.0.0.1:8080/docs, and run the arrest CLI as followed:</p> <p><pre><code>$ arrest -u http://localhost:8080/openapi.json -d example_service\n</code></pre> This will generate <code>models.py</code>, containing the Pydantic schemas corresponding to the OpenAPI components, a <code>resources.py</code> containing the RESTful resource definitions and a <code>services.py</code> containing the service definition that includes the resources.</p> <p>To use the service, simply call <code>example_service.users.get(\"\")</code>.</p>"},{"location":"examples/#running-tests","title":"Running Tests","text":"<p>Create a virtualenv that contains the dependencies in the example directory, and run <code>pytest -vvv</code>.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>Assuming you already have arrest installed in your system, let us create a simple connection. We have a REST endpoint <code>http://example.com/api/v1</code> which has a resource <code>/user</code> with method <code>GET</code>.</p> <pre><code>from arrest import Service, Resource\n\nexample_svc = Service(\n    name=\"example\",\n    url=\"http://example.com/api/v1\",\n    resources=[\n        Resource(\n            name=\"user\",\n            route=\"/user\",\n            handlers=[\n                (\"GET\", \"/\")\n            ]\n        )\n    ]\n)\n</code></pre> <p>Now that our service is defined, we can proceed to use it elsewhere.</p> <pre><code>await example_svc.user.get(\"/\")\n</code></pre> <p>If we want to enable exception handling, simply import <code>ArrestHTTPException</code>, or more generic <code>ArrestError</code></p> <pre><code>from arrest.exceptions import ArrestHTTPException\n\ntry:\n    resp = await example_svc.user.get(\"/\")\nexcept ArrestHTTPException as exc:\n    print(f\"{exc.status_code} {exc.data}\")\n\nreturn resp\n</code></pre>"},{"location":"getting-started/#using-methods","title":"Using Methods","text":"<p>We have the following HTTP Methods available. They can be found in <code>arrest.http.Methods</code> enum.</p> <p><pre><code>GET\nPOST\nPUT\nPATCH\nDELETE\nHEAD\nOPTIONS\n</code></pre> There are also equivalent helper functions for each of these methods available for your resource. Simply run <code>.get</code>, <code>.post</code>, <code>.put</code>, <code>.patch</code>, <code>.delete</code>, <code>.head</code>, <code>.options</code>. Or you can directly make use of <code>.request()</code> and supply the method in it.</p>"},{"location":"getting-started/#retries","title":"Retries","text":"<p>There are no retries built-in in Arrest. However they can be configured in many different ways. You can use the retry mechanism from httpx transport (e.g. <code>httpx.AsyncHTTPTransport(retries=3)</code>), or use the <code>retry</code> field in <code>Service</code> or <code>Resource</code> specific setting and provide the number of retries. Arrest uses tenacity under-the-hood for its internal retries.</p> <p>If you want to learn more, please refer to this</p>"},{"location":"getting-started/#timeouts","title":"Timeouts","text":"<p>Arrest also provides a default timeout of 120 seconds (2 minutes) in all its http requests. If you want to provide a custom timeout, you can put it at a service-level or at a resource-level in the <code>timeout</code> argument. Alternatively, if you want to disable timeouts, you can do so by setting <code>timeout=httpx.Timeout(None)</code>.</p> <p>The <code>timeout</code> can take either an integer value for the number of seconds, or an instance of <code>httpx.Timeout</code>.</p> <p>If you set <code>timeout=None</code>, this is equivalent to <code>timeout=httpx.Timeout(None)</code>, which will disable timeouts for the client.</p> <pre><code>from arrest import Service, Resource\n\n\nexample_svc = Service(\n    name=\"example\",\n    url=\"http://example.com/api/v1\",\n    resources=[\n        Resource(\n            name=\"user\",\n            route=\"/user\",\n            handlers=[\n                (\"GET\", \"/\")\n            ]\n        )\n    ],\n    timeout=240 # 4 minutes\n)\n</code></pre>"},{"location":"getting-started/#using-a-pydantic-model-for-request","title":"Using a Pydantic model for request","text":"<p>You can also provide an additional request type for your handlers. This can be done by passing a third entry to your handler tuple containing the pydantic class, or pass it directly to the handler dict or <code>ResourceHandler</code> initialization.</p> <pre><code>from pydantic import BaseModel\n\nclass UserRequest(BaseModel):\n    name: str\n    email: str\n    password: str\n    role: str\n\nResource(\n    route=\"/abc,\n    handlers=[\n        (\"POST\", \"/\", UserRequest) # or ResourceHandler(method=\"POST\", route=\"/\", request=UserRequest)\n                                   # or {\"method\": \"POST\", \"route\": \"/\", \"request\": UserRequest}\n    ]\n)\n</code></pre> <p>Notice how we only supplied <code>route</code> for our resource? Arrest automatically infers the resource name based on the resource route. Hence we have deduced our resource to be <code>abc</code>.</p> <p>Now that our handler is initialized with a request, we can make a request with instances of type <code>UserRequest</code></p> <p>Important</p> <p>All fields in the pydantic model by default will be sent as the JSON body payload. If you want to send other params such as <code>headers</code> or <code>query</code>, see below.</p>"},{"location":"getting-started/#using-a-pydantic-model-for-response","title":"Using a pydantic model for response","text":"<p>Similar to request, you can pass an additional fourth argument in the handler tuple for specifying a pydantic model for the handler. If provided it will automatically deserialize the returned success json response into either a model instance or a list of model instances.</p> <pre><code>class UserResponse(BaseModel):\n    name: str\n    email: str\n    role: str\n    created_at: datetime\n    updated_at: datetime\n    is_deleted: bool\n\nResource(\n    route=\"/user\",\n    handlers=[\n        (\"GET\", \"/{user_id}\", None, UserResponse), # if no request type to be supplied, leave it as `None`\n    ]\n)\n\nresponse = await svc.user.get(f\"/{user_id}\") # type: UserResponse\n</code></pre>"},{"location":"getting-started/#using-a-callback","title":"Using a callback","text":"<p>Sometimes you want to chain a call to another function with the response you get from the api. This can be something like logging or auditing somewhere or triggering another api. You can already do that by calling the function after awaiting the api call response. However, Arrest provides a dedicated <code>callback</code> option for each handler, which can be passed as the fifth argument to the handler tuple (or set as a field in the dict or <code>ResourceHandler</code>). <code>callback</code> can take any callable that can be either sync or async. If it is specified, the response type from the api call will be the response type of the callback.</p> <p>Note</p> <p>if you specify a response type to your handler, the callback needs to accept argument of appropriate response type.</p> <p>Any exception thrown by the callback is re-raised.</p> <pre><code>async def demo_callback(data: Any):\n    await asyncio.sleep(1)\n    logging.info(\"foo has been barred\")\n    return None\n\nservice.add_resource(\n    Resource(\n        route=\"/user\",\n        handlers=[\n            ResourceHandler(\n                method=Methods.GET,\n                route=\"/\",\n                callback=demo_callback,\n            )\n        ],\n    )\n)\n\nresponse = await service.user.get(\"/\")\n# &gt;&gt;&gt; foo has been barred\n# response == None\n</code></pre>"},{"location":"getting-started/#handling-exceptions","title":"Handling exceptions","text":"<p>All of Arrest's exceptions/errors subclass <code>ArrestError</code>. The most important one is <code>ArrestHTTPException</code> which wraps the httpx-specific errors that might occur from making a request. Any response that does not have a success status code (i.e. 200-299) will throw an <code>ArrestHTTPException</code> with the appropriate <code>status_code</code> and <code>data</code>.</p> <p>Example</p> <pre><code>try:\n    response = await xyz_service.users.get(\"/123\")\nexcept ArrestHTTPException as exc:\n    logging.warning(f\"{exc.status_code} {exc.data}\")\n    # do something with the error response\n</code></pre> <p>Any other error such as <code>TimeoutException</code> or <code>RequestError</code> will result in a <code>ArrestHTTPException</code> with <code>status_code=500</code> See API Documentation for further details.</p>"},{"location":"getting-started/#adding-a-custom-handler","title":"Adding a custom handler","text":"<p>If you want to add a custom function to handle an api request and have complete control over the request and response, you can use the <code>Resource.handler</code> decorator to decorate an async function and write your own custom logic. You have to specify the path relative to the resource in the decorators argument. This function will be registered as a method to the same resource you're decorating it with and can be accessed as <code>await resource.function_name(...)</code> You can also invoke the function as a free function as <code>await function_name(...)</code></p> <p>Important</p> <p>Creating a handler this way does not have any data validation or pydantic wrapping enabled. Neither does it do exception handling. It only does the default retry on httpx Exceptions using <code>backoff</code>.</p> <p>If you use the decorator, the first two arguments of your decorated function will have to be defined as <code>self</code> and <code>url</code>. The <code>url</code> will be the fully-constructed path using the service's <code>base_url</code>, the resource's <code>route</code> and the provided <code>path</code> in the decorator, should you choose to use it,</p> <p>The <code>self</code> argument is a reference to the same resource instance you're decorating the function with, this means you can access all the members of the <code>Resource</code> class inside your function. Including <code>self._client</code>, which is where your custom client instance is stored if you have set it during your resource initialization (or injected it via service).</p> <p>You can also access all the httpx related args using <code>self._httpx_args</code> which is a <code>TypedDict</code>, so you can easily instantiate your own AsyncClient by unpacking and initializing with those args.</p> <p>Or you can just roll with your own custom logic.</p> <p>Once defined you have to access the function via the resource instance, as it is now a member of your resource.</p> <p>Example</p> <pre><code>res = Resource(\n    route=\"/user\",\n    handlers=[\n        (\"GET\", \"/\"),\n        (\"POST\", \"/\"),\n    ]\n)\n\nsvc = Service(\n    name=\"my_service\",\n    url=\"http://www.example.com\",\n)\n\nsvc.add_resource(res)\n\n@svc.user.handler(\"/media\")\nasync def download_user_metadata(self, url, *, meta_id: int):\n    # url == http://www.example.com/user/media\n    urlnew = f\"{url}/{meta_id}\n    async with httpx.AsyncClient(...) as client:\n        resp = await client.get(urlnew)\n        ...\n\n    # or\n    async with httpx.AsyncClient(**self._httpx_args) as client:\n        resp = await client.get(urlnew)\n\n    # or\n    resp = await self._client.get(urlnew) # if client is specified\n\n\nmetadata = await svc.user.download_user_metadata(meta_id=123)\n\n# or\nmetadata = await download_user_metadata(meta_id=123)\n</code></pre>"},{"location":"openapi/","title":"OpenAPI Integration","text":"<p>Arrest additionally offers integration to OpenAPI specification (formerly Swagger).</p> <p>With it, you can generate the necessary boilerplates for Arrest services and resources directly from the API route specifications. Arrest uses datamodel-code-generator under the hood to generate the data transfer models in Pydantic, and add Arrest resource and service templates on top of that.</p> <p>Note</p> <p>this feature is experimental and does not quite cover the extensive range of features of OpenAPI specification. We will be gradually rolling out new features from OpenAPI specification that also suits the functionalities of Arrest.</p>"},{"location":"openapi/#usage","title":"Usage","text":"<pre><code>pip install \"arrest[openapi]\"\n\npoetry add 'arrest[openapi]'\n</code></pre> <p>This installs two additional dependencies.</p> <ol> <li>datamodel-code-generator</li> <li>jinja2</li> </ol> <p>Once installed, you can use the CLI interface to provide a OpenAPI Specification url (http or a filepath) and it will generate the files from the spec.</p> <pre><code>arrest --url https://petstore3.swagger.io/api/v3/openapi.json\n</code></pre> <p>This generates 3 files. 1. <code>models.py</code> - a file containing all the schema definitions found in the OpenAPI Spec <code>/components/schemas</code>, generated by <code>datamodel-code-generator</code></p> <ol> <li> <p><code>resources.py</code> - a set of Arrest resource definitions based on the defined routes in the Spec <code>/paths</code></p> </li> <li> <p><code>services.py</code> - a list of Arrest services based on the Spec <code>/servers</code>, if there is a server definition with <code>serverVariables</code>, Arrest will generate as many service instance as there are unique server urls from all the combinations of <code>serverVariables</code></p> </li> </ol> <p>Example</p> <pre><code>&gt;&gt;&gt; arrest --url https://petstore3.swagger.io/api/v3.1/openapi_3.1.json -o path/to/destination\n</code></pre> <p>this will create a directory named <code>swagger_petstore_openapi_3_1</code> (based on the <code>title</code> in the OpenAPI specification) in <code>path/to/destination</code>, inside which it will generate the following</p> <pre><code># swagger_petstore_openapi_3_1/models.py\n\n# generated by datamodel-codegen:\n#   filename:  &lt;stdin&gt;\n#   timestamp: 2024-01-29T18:57:34+00:00\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    id: int\n    name: str\n    tag: Optional[str] = None\n\n\nclass Pets(BaseModel):\n    __root__: List[Pet]\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\n\n# swagger_petstore_openapi_3_1/resources.py\n\nfrom arrest import Resource\nfrom .models import Pet, Pets\n\npets = Resource(\n    name=\"pets\",\n    route=\"/pets\",\n    handlers=[\n        (\"GET\", \"\", None, Pets),\n        (\"POST\", \"\", None, None),\n        (\"GET\", \"/{petId}\", None, Pet),\n    ]\n)\n\n\n# swagger_petstore_openapi_3_1/services.py\n\nfrom arrest import Service\nfrom .resources import pet, store, user\n\nswagger_petstore_openapi_3_0 = Service(\n    name=\"swagger_petstore_openapi_3_0\",\n    url=\"/api/v3\",\n    resources=[pet, store, user]\n)\n</code></pre> <p>The files generated are not black-formatted or isort-formatted. Hence further customization is left to the user.</p>"},{"location":"openapi/#cli-arguments","title":"CLI Arguments","text":"<pre><code>usage:\n    arrest [options] --help\n\ngenerate arrest services and resources from various definitions\n\noptions:\n  -h, --help            show this help message and exit\n  -o OUTPUT, --output OUTPUT\n                        output directory for generated files (default: current working directory)\n  --pydantic {v1,v2}    pydantic version to generate the schema definitions\n  -u URL, --url URL     HTTP or file url for the openapi schema\n  -d DIR, --dir DIR     Folder containing the files (default: OpenAPI specification title)\n</code></pre> <p>By default Arrest will look for the <code>title</code> of the specification and use that to name the directory that contains these files. If it can't find one, it will use <code>api</code> as the directory name instead. Alternatively you can specify your own custom name by providing <code>-d</code> or <code>--dir</code></p> <p><code>--pydantic</code> is used to denote the pydantic version (<code>v1</code> or <code>v2</code>) that the generated schema definitions will use (defaults to <code>v1</code>)</p>"},{"location":"openapi/#what-works-and-what-does-not","title":"What works and what does not","text":"<ol> <li> <p>Currently, Arrest is able to only work on singular pydantic types and not types like <code>list[BaseModel]</code> or <code>dict[str, BaseModel]</code> as request / response models. As a result, schema definitions in OpenAPI that are of the following types: <pre><code>{\n    \"type\": \"array\",\n    \"items\": {\n        \"$ref\": \"#/components/Schemas/User\"\n    }\n}\n</code></pre> are not parsed. Same for any schema definitions that don't have a <code>$ref</code> to a model definition.</p> </li> <li> <p><code>Parameters</code> such as path or query or headers are not parsed currently. Although formatted path interpolation is available. If your path definition is something like <code>/abc/{xyz}</code>, the Arrest resource <code>abc</code> will have a handler with path <code>/{xyz}</code> and you can pass <code>xyz</code> as a kwarg when calling this route.</p> </li> </ol> <p>Example</p> <pre><code>abc = Resource(\n    name=\"abc\",\n    route=\"/abc\",\n    handlers=[\n        (\"GET\", \"/{xyz}\", None, None),\n    ]\n)\n\n\nawait my_service.abc.get(xyz=123)\n# or\nawait my_service.abc.get(\"/123\")\n</code></pre> <ol> <li>OpenAPI Security definitions are not parsed.</li> </ol> <p>There is a bit of manual intervention needed if the extraction from the OpenAPI Spec is incomplete. You can subclass the generated schema classes and add extra parameters as <code>Header()</code> or <code>Query()</code> parameters.</p> <p>Additionally, you can use it as a module and extend its functionalities. <pre><code>from arrest.openapi import OpenAPIGenerator\n\n...\n</code></pre></p> <p>For more info, check the API Documentation</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#0110-latest","title":"0.1.10 (Latest)","text":""},{"location":"release-notes/#added","title":"Added","text":"<ul> <li> <p>Added support for decorating custom handlers for your resource using <code>@my_resource.handler(/path/to/something)</code>.</p> </li> <li> <p>Added support for root-level resources. Now you can add a resource with a route of <code>\"\"</code> or <code>\"/\"</code>. However, a service can only have only one root-level resource.</p> </li> <li> <p>Added a more flexible retry mechanism with better user control. You can now choose between the built-in retry mechanism, the retry from <code>HTTPTransport</code> class by <code>httpx</code>, or configure your own custom retry wrapper. Or you can opt to choose the default behaviour of no retries.</p> </li> <li> <p>Added support for any serializable python types as request and response types. This includes Pydantic basemodel and rootmodels, dataclasses, and python types which are json serializable.</p> </li> <li> <p>Added custom exception handlers. You can write your custom hooks on specific exceptions made by the HTTP calls and attach them to your service.</p> </li> <li> <p>Add support for writing query parameters into the url string. You can now write the query parameters as part of the url string, i.e. <code>service.user.get(\"/all?limit=10&amp;role=admin\")</code>.</p> </li> <li> <p>Add support for default GET handlers for resources. When defining arrest Resources, a default GET handler to the resource root is always added by default.</p> </li> <li> <p>Add named constants for HTTP Methods. You can simply use <code>from arrest import GET</code>, and create handlers using the named constant for method, <code>(GET, \"/\", UserRequest, UserResponse)</code>.</p> </li> </ul>"},{"location":"release-notes/#fixed","title":"Fixed","text":"<ul> <li> <p>Fixed the generated names of resource and services having whitespaces and special characters after parsing the OpenAPI Specification by standardizing the naming with using lower case and snake_case</p> </li> <li> <p>Fixed improper imports of pydantic schemas from the OpenAPI generation. Certain schema names in the generated OpenAPI spec caused some import issues, which was fixed.</p> </li> </ul> <p>For more information, check out What's New</p>"},{"location":"release-notes/#019","title":"0.1.9","text":"<p>Feb 14, 2024</p>"},{"location":"release-notes/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed pydantic dependency to support <code>&gt;=1.10.13</code></li> </ul>"},{"location":"release-notes/#018","title":"0.1.8","text":"<p>Jan 31, 2024</p>"},{"location":"release-notes/#added_1","title":"Added","text":"<ul> <li>Added optional OpenAPI Integration to automatically generate the Pydantic models, Arrest resources and services from the specification.</li> </ul>"},{"location":"release-notes/#017","title":"0.1.7","text":""},{"location":"release-notes/#_1","title":"","text":""},{"location":"release-notes/#016","title":"0.1.6","text":""},{"location":"release-notes/#_2","title":"","text":""},{"location":"release-notes/#015","title":"0.1.5","text":"<p>Jan 2, 2024</p>"},{"location":"release-notes/#added_2","title":"Added <ul> <li>Added support for most of the HTTPX client arguments as kwargs to be passed into both Service and Resource class. This includes things like cookies, auth, transport, cert etc. That way you can reuse a transport object in all your resources / services.</li> <li>Added backoff retries for all the http calls with configurable no. of retries.</li> <li>Added support for providing your own <code>httpx.AsyncClient</code> instance as a field in both <code>Service</code> and <code>Resource</code> class. This can also be any other class that subclasses <code>httpx.AsyncClient</code> (for example, the Oauth2 client from authlib).</li> <li>Added a new decorator <code>.handler(...)</code> for a resource to decorate a custom user-defined function for a resource sub-path. This enables more fine-grained control over the http calls and also injects the a reference to the resource instance inside the function for easier access.</li> </ul>","text":""},{"location":"release-notes/#misc","title":"Misc <ul> <li>General bug fixes</li> <li>Documentation changes</li> </ul>","text":""},{"location":"release-notes/#014","title":"0.1.4","text":"<p>Dec 15, 2023</p>"},{"location":"release-notes/#fixed_2","title":"Fixed <ul> <li>Fix #11 - url paths are now constructed using posixpath. Assuming all the components of the path are put in a hierarchical manner (service -&gt; resource -&gt; handler)</li> </ul>","text":""},{"location":"release-notes/#013","title":"0.1.3","text":"<p>Dec 10, 2023</p>"},{"location":"release-notes/#added_3","title":"Added <ul> <li>Added backwards compatibility with pydantic@1.10.13 and above</li> </ul>","text":""},{"location":"release-notes/#misc_1","title":"Misc <ul> <li>General code and documentation refactor</li> </ul>","text":""},{"location":"release-notes/#012","title":"0.1.2","text":"<p>Dec 8, 2023</p>"},{"location":"release-notes/#fixed_3","title":"Fixed <ul> <li>Fixed issue with paths ending / not-ending with trailing slashes</li> <li>Fixed root handlers not getting matched</li> <li>Refactored test suite</li> </ul>","text":""},{"location":"release-notes/#added_4","title":"Added <ul> <li>Added header and query kwargs for request</li> </ul>","text":""},{"location":"release-notes/#misc_2","title":"Misc <ul> <li>General refactors</li> </ul>","text":""},{"location":"release-notes/#011","title":"0.1.1","text":"<p>Dec 2, 2023</p>"},{"location":"release-notes/#minor-release","title":"Minor release","text":""},{"location":"release-notes/#010","title":"0.1.0","text":"<p>Dec 2, 2023</p>"},{"location":"release-notes/#initial-release-minor","title":"Initial release - minor","text":""},{"location":"resources-services/","title":"Resources and Services","text":""},{"location":"resources-services/#resources","title":"Resources","text":"<p>A resource can be thought of as an entity that provides one or more HTTP verb accessors and / or subresources.</p> <p>Resources have a base <code>route</code>, a <code>name</code>, (or derived from <code>route</code>), and a list of handlers.</p> <p>Handlers are a list of paths and their correspnding HTTP verb. These are the many different ways of interacting with the said resource.</p> <p>For example, you can define a resource as followed:</p> <pre><code>user = Resource(\n    route=\"/users\",\n    handlers=[\n        (\"GET\", \"/\"),\n        (\"POST\", \"/\"),\n        (\"PUT\", \"/{user_id:int}\"),\n        (\"DELETE\", \"/{user_id:int}\"),\n        (\"GET\", \"/posts\"),\n        (\"POST\", \"/posts\"),\n    ]\n)\n</code></pre>"},{"location":"resources-services/#resource-wide-response-model","title":"Resource-wide response model","text":"<p>You can define a resource-level response model if you want to streamline the output structure for all the handlers to the same response model.</p> <pre><code>from pydantic import BaseModel\nfrom arrest import Resource\n\nclass UserResponse(BaseModel):\n    ...\n\nuser = Resource(\n    route=\"/users\",\n    handlers=[\n        (\"GET\", \"/\"),\n        (\"POST\", \"/\"),\n        (\"PUT\", \"/{user_id:int}\"),\n        (\"DELETE\", \"/{user_id:int}\"),\n    ],\n    response_model=UserResponse\n)\n</code></pre>"},{"location":"resources-services/#using-a-client-directly","title":"Using a client directly","text":"<p>You can choose to run with your own <code>httpx.AsyncClient</code> instance. Simply set the <code>client</code> field to your resource.</p> <pre><code>...\nimport httpx\n\nmy_client = httpx.AsyncClient(...)\n\nuser = Resource(\n    route=\"/users\",\n    handlers=[\n        (\"GET\", \"/\"),\n        (\"POST\", \"/\"),\n        (\"PUT\", \"/{user_id:int}\"),\n        (\"DELETE\", \"/{user_id:int}\"),\n    ],\n    response_model=UserResponse,\n    client=my_client\n)\n</code></pre> <p>You can also use any instance that is a subclass of <code>httpx.AsyncClient</code> (e.g. AsyncOauth2Client from authlib)</p> <p>The caveat is that you have to manually close the client after you are done. Usually by <code>await client.aclose()</code> or something else.</p> <p>Note</p> <p>There is also a <code>client</code> field in <code>Services</code>. You can also use it to set a service-wide shared client instance</p>"},{"location":"resources-services/#using-httpx-arguments","title":"Using httpx arguments","text":"<p>You can directly pass most of the httpx client arguments as kwargs for the Resource instance. This allows you to have a more fine-grained control on configuring the httpx client.</p> <p>For the full list of available arguments, please check here</p>"},{"location":"resources-services/#services","title":"Services","text":"<p>Services are the main entrypoint to your API calls. A service is a single url endpoint of a server whose REST APIs you are going to interface. A service has the following core fields.</p> <ul> <li>name - name of the service</li> <li>url - URl of the service (without any trailing slashes)</li> <li>resources - a list of resources for this service</li> </ul>"},{"location":"resources-services/#using-a-client-directly_1","title":"Using a client directly","text":"<p>You can choose to run with your own <code>httpx.AsyncClient</code> instance. Simply set the <code>client</code> field to your service.</p> <p>This client will override any client set by any resource, and will be shared across all the http calls.</p> <pre><code>...\nimport httpx\n\nmy_client = httpx.AsyncClient(...)\n\nuser = Resource(\n    route=\"/users\",\n    handlers=[\n        (\"GET\", \"/\"),\n        (\"POST\", \"/\"),\n        (\"PUT\", \"/{user_id:int}\"),\n        (\"DELETE\", \"/{user_id:int}\"),\n    ],\n    response_model=UserResponse,\n    client=my_client\n)\n</code></pre> <p>As stated previously, you are in charge of closing the client.</p>"},{"location":"resources-services/#using-httpx-arguments_1","title":"Using httpx arguments","text":"<p>You can directly pass most of the httpx client arguments as kwargs for the Service instance.</p> <p>This will override these fields if also set from any resource under this service.</p> <p>For the full list of available arguments, please check here</p>"},{"location":"resources-services/#root-resources","title":"Root resources","text":"<p>Root resources are special resource definitions that have an empty (root) route (<code>\"\"</code>) or (<code>\"/\"</code>). These are usually top-level endpoints usually used for ping or healthcheck. We use the reserved name <code>root</code> to identify these root resources. If you want to integrate a root resource in your service, simply add it to the list of resources.</p> <pre><code>from arrest import Service, Resource\n\nservice = Service(\n    name=\"myservice\",\n    url=\"http://example.com\",\n    resources=[\n        Resource(\n            route=\"\",\n            handlers=[\n                (\"GET\", \"\"),\n                (\"GET\", \"/health\")\n            ]\n        )\n    ]\n)\n</code></pre> <p>Note</p> <p>You can only have one root resource. A resource that has its base route <code>\"\"</code>, and another having base route of <code>\"/\"</code> are both root resources and one will override the other. If you want to have both <code>\"\"</code> and <code>\"/\"</code> routes accessible, specify them as separate handlers in your root resource</p> <pre><code>Resource(\n    route=\"\",\n    handlers=[\n        (\"GET\", \"\"),\n        (\"GET\", \"/\"),\n        (\"GET\", \"/health\")\n    ]\n)\n</code></pre> <p>To call the endpoints of root resource, you call the HTTP method on the service directly, only specifying the path. Alternatively, you can use <code>.root</code> to explicitly specify the root resource and call its handlers by path and method.</p> <p>Example</p> <pre><code>from arrest import Resource, Service\n\nroot_resource = Resource(\n    route=\"\",\n    handlers=[\n        (\"GET\", \"\"),       # 1\n        (\"GET\", \"/\"),      # 2\n        (\"GET\", \"/health\") # 3\n    ]\n)\n\nmyservice = Service(\n    name=\"myservice\",\n    url=\"http://example.com\",\n    resources=[root_resource]\n)\n\nawait myservice.get(\"\")        # calls #1\nawait myservice.get(\"/\")       # calls #2\nawait myservice.get(\"/health\") # calls #3\n\nawait myservice.root.get(\"/\")  # also works\n</code></pre>"},{"location":"whats-new/","title":"What's New?","text":""},{"location":"whats-new/#added-support-for-decorating-custom-handlers-for-your-resource","title":"Added support for decorating custom handlers for your resource.","text":"<p>Earlier in v0.1.9 the decorator could only be used with a resource under its parent service's scope:</p> <pre><code>@myservice.user.handler(\"/path\")\nasync def path_handler(self, url, *args, **kwargs):\n    ...\n</code></pre> <p>This was not a clear separation of concern. Ideally in Arrest, we want you to be able to define everything relating to a resource within the resource, and everything relating to a service within the service, and simply interface the resources with your service, or multiple services. In v0.1.10, you can use the handler with your resource, without having to connect it to a service first and use the service's scope:</p> <pre><code># resource.py\nfrom arrest import Resource\n\nuser = Resource(\n    route=\"/user\",\n    handlers=[...]\n)\n\n@user.handler(\"/upload-pic\")\nasync def upload_user_profile_pic(self, url, *arg, *kwarg):\n    ...\n...\n\n# service.py\nfrom .resource import user\n\nmyservice = Service(\n    name=\"myservice\",\n    url=\"http://example.com\",\n    resources=[user]\n)\n\n...\n\n# somewhere_else.py\nfrom .service import myservice\n\nawait myservice.user.upload_user_profile_pic(...)\n</code></pre> <p>Note</p> <p>Connecting your resource to a service is still mandatory if you want to use the complete url. If you just call the method from your resource instance directly, since its still not bound to a service (thus a <code>base_url</code>), it would try to make an api call to <code>/user/upload-pic</code>, instead of <code>http://example.com/user/upload-pic</code></p>"},{"location":"whats-new/#standardized-the-names-of-resource-and-services-from-parsing-the-openapi-specification","title":"Standardized the names of resource and services from parsing the OpenAPI Specification.","text":"<p>Certain names for resources and services had whitespaces and special characters, which resulted in the generated code having illegal variable names (such as <code>OpenAPI service: 2.1 = Service(...)</code>)</p> <p>v0.1.10 standardizes all variable names of the generated service and resource to lower and snake_cased.</p>"},{"location":"whats-new/#add-support-for-root-level-resources","title":"Add support for root-level resources.","text":"<p>You can now define root-level resources (i.e., having base routes of either <code>\"\"</code> or <code>\"/\"</code>) There can be only one root-level resource, for obvious reasons. You can set them up as normal <code>Resource</code> instances with <code>route=\"\"</code> or <code>route=\"/</code>\" and a corresponding handler <code>(&lt;Method&gt;, \"\")</code> (e.g. <code>www.example.com</code>) or <code>(&lt;Method&gt;, \"/\")</code> (e.g. <code>www.example.com/</code>)</p> <p>In order to make the call to the root-resource, you simply invoke the http methods on the service directly, without specifying a resource.</p> <pre><code>await my_service.get(\"\") # or my_service.get(\"/\")\n</code></pre> <p>Note</p> <p>This is only applicable if you have a path with no suffix at the root level. i.e. <code>www.example.com/</code>. If you want to access <code>www.example.com/path</code>, then the following won't work.</p> <pre><code>Resource(route=\"/\", handlers=[(\"GET\", \"/path\")])\n\nawait service.get(\"/path\") # throws ResourceNotFound\n</code></pre> <p>Because <code>/path</code> constitutes a resource on its own, not a subpath for a root-resource <code>/</code>, hence the following would need to be written</p> <pre><code>Resource(route=\"/path\", handlers=[(\"GET\", \"\")])\n\nawait service.path.get(\"\") # works!\n</code></pre> <p>General rule-of-thumb is, a RESTful resource always has a path prefix, and arrest resources should preferrably be designed around that notion. If you have an endpoint with only the root-level being the accessible API, you might want to create a root-resource with a single handler.</p>"},{"location":"whats-new/#standardized-retry-mechanism-with-more-flexibility","title":"Standardized retry mechanism with more flexibility","text":"<p>The previous built-in retry mechanism was too restrictive and lacked configurability. In the new version, there will not be any retry by default. This is to reduce as much side-effect as possible from the HTTP calls in favour of developer expectations. If you want to enable retries there are a few different ways.</p>"},{"location":"whats-new/#use-the-standard-retry-mechanism-from-httpx-transport","title":"Use the standard retry mechanism from httpx transport","text":"<pre><code>from httpx import AsyncHTTPTransport\nfrom arrest import Resource, Service\n\ntransport = AsyncHTTPTransport(retries=3)\n\nmy_service = Service(\n    name=\"myservice\",\n    url=\"http://example.com\",\n    resources=[user],\n    transport=transport\n)\n</code></pre> <p>or, if you are running your own httpx client instance, you can also configure it there.</p> <pre><code>my_service = Service(\n    name=\"myservice\",\n    url=\"http://example.com\",\n    resources=[user],\n    client=httpx.AsyncClient(transport=transport)\n)\n</code></pre> <p>This will retry the request in case of <code>httpx.ConnectError</code> or <code>httpx.ConnectTimeout</code>. Read more</p>"},{"location":"whats-new/#use-the-retry-mechanism-from-arrest","title":"Use the retry mechanism from arrest","text":"<p>Arrest provides an additional keyword-argument <code>retry</code> either at service-level, or at individual resource-level. It is defaulted to <code>None</code>, should you opt for no retries (the default behaviour). However, you can set it to any valid integer resembling the number of times it should retry.</p> <p>Arrest uses tenacity under-the-hood for its internal retry process. It uses random exponential backoff and in the event of any exception.</p> <pre><code>my_service = Service(\n    name=\"myservice\",\n    url=\"http://example.com\",\n    resources=[user],\n    retry=3\n)\n</code></pre>"},{"location":"whats-new/#use-your-own-retry-mechanism","title":"Use your own retry mechanism","text":"<p>If you want more fine-grained control over your retries, you can disable the in-built retry (<code>retry=None</code>), or keep it unset (default None) and write your own decorator that wraps around your anciliary function that calls the arrest service under the decorator. Here is an example using another popular library backoff</p> <pre><code>import backoff\nfrom arrest.exceptions import ArrestHTTPException\n\n@backoff.on_exception(\n    backoff.expo,\n    (\n        ArrestHTTPException,\n        Exception\n    ),\n    max_retries=5,\n    jitter=backoff.full_jitter\n)\nasync def fn_caller():\n    return await my_service.foo.get(\"/bar\")\n</code></pre> <p>Note</p> <p>When calling the arrest service, do remember that the original httpx exceptions are rethrown as <code>ArrestHTTPException</code> with the appropriate information. These include the following:</p> <ul> <li><code>httpx.HTTPStatusError</code> - for capturing HTTP non-200 error codes, rethrown as <code>ArrestHTTPException</code> with the same status code and message</li> <li><code>httpx.TimeoutException</code> - for capturing any request timeout, rethrown as <code>ArrestHTTPException</code> with the status code 408 (Request Timeout)</li> <li><code>httpx.RequestError</code> - any other error during making the request, rethrown as <code>ArrestHTTPException</code> with the status code 500 (Internal Server Error)</li> </ul>"},{"location":"whats-new/#add-support-for-passing-any-python-type-to-the-request-and-response-type-definitions-for-handlers","title":"Add support for passing any Python-type* to the request and response type definitions for handlers.","text":"<p>With v0.1.10, you can use any python type (that is json-serializable, ofcourse) for request and response in the handler definitions. The following types are tested for full support: 1. <code>primitive types</code> 2. <code>pydantic.BaseModel</code> 3. <code>dataclasses.dataclass</code> 4. <code>pydantic.RootModel</code> (v2 only) 5. <code>dict</code> and <code>typing.Dict</code> 6. <code>list</code> and <code>typing.List</code> 7. <code>typing.Optional</code> and <code>typing.Union</code></p> <p>You can use any combination of them to define your request and response types, and the requests / responses will be parsed according to the type definitions.</p> <p>Example</p> <pre><code>from arrest import Resource, Service\nuser = Resource(\n            name=\"users\",\n            route=\"/users\",\n            handlers=[\n                (\"GET\", \"\", None, UserSchema),\n                (\"POST\", \"\", UserCreate, UserSchema),\n                (\"GET\", \"/{user_id}\", None, UserSchema),\n                (\"GET\", \"/all\", None, list[UserSchema])\n            ]\n        )\n\nmy_service = Service(\n    name=\"myservice\",\n    url=\"http://example.com\",\n    resources=[user],\n)\n\nresponse = await my_service.user.get(\"/all?limit=10\") # list[UserSchema]\n</code></pre>"},{"location":"whats-new/#add-custom-exception-handlers","title":"Add custom exception handlers","text":"<p>If you need to enable some custom functionality for any exception during the lifetime of the HTTP request, you can now add custom exception handlers. Oftentimes, you would like to reraise the exception as a <code>fastapi.HTTPException</code> if you are proxying the requests to the service. A typical example use-case would look something like this:</p> <pre><code>from arrest.exceptions import ArrestHTTPException, ArrestError\n\ndef http_exc_handler(exc: ArrestHTTPException):\n        raise HTTPException(status_code=exc.status_code, detail=exc.data)\n\ndef err_handler(_exc: ArrestError):\n    raise HTTPException(status_code=500, detail=\"Something went wrong\")\n\ndef generic_err_handler(_exc: Exception):\n    logging.warning(\"Something went wrong\")\n\n\nmy_service = Service(\n    name=\"myservice\",\n    url=\"http://example.com\",\n    resources=[user],\n)\n\nservice.add_exception_handlers(\n    exc_handlers={\n        Exception: generic_err_handler,\n        ArrestHTTPException: http_exc_handler,\n        ArrestError: err_handler,\n    }\n)\n</code></pre> <p>This makes the service automatically call the appropriate exception handler function upon receiving the specific exception after making the request.</p> <p>Note - Arrest rethrows the <code>httpx</code> exceptions as <code>ArrestHTTPException</code>, hence you won't be able to, for example, use exception handlers for <code>httpx.HTTPStatusError</code>.</p>"},{"location":"whats-new/#add-support-for-writing-query-parameters-into-the-url-string","title":"Add support for writing query parameters into the url string","text":"<p>So far the query parameters had to be provided as an additional keyword-argument to the method caller as <code>service.get(\"/users\", query={\"limit\": 10})</code>. This was due to the fact that the url pattern matching for the correct handler was based on the complete url parameter, including the query params (the first argument of the method caller). However, now that condition is removed, you can also write the query parameters in the url string as <code>?limit=10</code>.</p> <pre><code>await service.users.get(\"/all?limit=10&amp;role=admin\")\n</code></pre>"},{"location":"whats-new/#add-support-for-default-get-handlers-for-resources","title":"Add support for default GET handlers for resources","text":"<p>Arrest now automatically adds a default GET handler to the resource route, which means, if your resource looks like this:</p> <pre><code>user = Resource(\n    name=\"user\",\n    route=\"/user\"\n)\n</code></pre> <p>You wouldn't need to add any handler for the resource root, you can directly call <code>service.user.get(\"\")</code> Additionally, if you specify <code>response_model</code> keyword-argument in the Resource initializer, the GET response will be automatically parsed as the <code>response_model</code>.</p> <pre><code>user = Resource(\n    name=\"user\",\n    route=\"/user\",\n    response_model=UserSchema\n)\n\nresponse = await service.user.get(\"\")\nassert isinstance(response, UserSchema) # True\n</code></pre> <p>Note</p> <p>This works by splitting the resource route into the resource's base route, and the suffix, which becomes the default GET handler route. For example, if your resource route is <code>\"/users\"</code>, the default handler will be <code>(\"GET\", \"\")</code>, and you can call <code>service.users.get(\"\")</code> But if your resource route is <code>\"/users/\"</code>, the default handler will be <code>(\"GET\", \"/\")</code>, and you can call <code>service.users.get(\"/\")</code>.</p> <p>This also works similarly for root-level resources for the service. If your root-level resource is at <code>\"/\"</code>, you can call <code>service.get(\"/\")</code> or <code>service.root.get(\"/\")</code>, but if the root-level resource is at <code>\"\"</code>, you have to call <code>service.get(\"\")</code> or <code>service.root.get(\"\")</code>.</p> <p>You can overwrite the default handler by rewriting it in the handlers list.</p> <pre><code>user = Resource(\n    name=\"user\",\n    route=\"/user\",\n    handlers=[\n        (\"GET\", \"\", UserSchema), # overwrites default (\"GET\", \"\")\n        (\"GET\", \"/{usder_id:str}\", UserSchema)\n    ]\n)\n</code></pre>"},{"location":"whats-new/#fixed-improper-imports-of-pydantic-schemas-from-the-openapi-generation","title":"Fixed improper imports of pydantic schemas from the OpenAPI generation","text":"<p>The OpenAPI schema that is generated by FastAPI can have weird names for the schema components. If your FastAPI endpoint does not have a predefined Pydantic model for it's request but instead you are using them as the endpoint function parameters, the generated schema name will be</p> <pre><code>@app.post(\"/foo\")\nasync def post_custom_request_with_query_header_body(\n    request: Request,\n    foo: str = Body(...),\n    bar: str = Body(...),\n    x_api_key: str = Header(...),\n    x_secret: str = Header(...),\n    limit: Optional[int] = Query(10),\n    user_id: Optional[str] = Query(None),\n):\n    ...\n</code></pre> <p>The above endpoint generates the following openapi schema:</p> <pre><code>\"Body_post_custom_request_with_query_header_body_custom_post\": {\n    \"properties\": {\n        \"foo\": {\n        \"type\": \"string\",\n        \"title\": \"Foo\"\n        },\n        \"bar\": {\n        \"type\": \"string\",\n        \"title\": \"Bar\"\n        }\n    },\n    \"type\": \"object\",\n    \"required\": [\n        \"foo\",\n        \"bar\"\n    ],\n    \"title\": \"Body_post_custom_request_with_query_header_body_custom_post\"\n    }\n</code></pre> <p>When parsing this OpenAPI schema, the generated pydantic schema uses correct pascal-casing (<code>class BodyPostCustomRequestWithQueryHeaderBodyCustomPost</code>), but when importing them in the generated <code>resources.py</code> they were incorrectly using the snake_case name from the OpenAPI specification. This has been fixed now, and both <code>models.py</code> and <code>resources.py</code> will have the correct PascalCase named imports of the schema models.</p>"},{"location":"whats-new/#named-constants-for-http-methods","title":"Named constants for HTTP Methods","text":"<p>Instead of writing HTTP methods as string literals, or using <code>arrest.http.Methods</code> enum, you can also import them as constants.</p> <pre><code>from arrest import GET, POST, Resource\n\nuser = Resource(\n    name=\"user\",\n    route=\"/user\",\n    handlers=[\n        (GET, \"/\"),\n        (POST, \"/login\")\n    ]\n)\n</code></pre>"}]}